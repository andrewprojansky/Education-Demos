"""Code to simulate quantum circuits, with intention of being self contained in all operations and objects, with full comments and documentationProject Start Date: 9/21/22"""import numpy as npimport random"""Defines important gates for computation; clifford gates, T, and custom gates"""H = np.array([[1 / np.sqrt(2), 1 / np.sqrt(2)], [1 / np.sqrt(2), -1 / np.sqrt(2)]])S = np.array([[1, 0], [0, 1j]])T = np.array([[1, 0], [0, np.exp(1j*np.pi/4)]])X = np.array([[0,1],[1,0]])Y = np.array([[0,-1j],[1j, 0]])Z = np.array([[1,0],[0,-1]])CNotF = np.array([[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]])CNotB = np.array([[1,0,0,0],[0,0,0,1],[0,0,1,0],[0,1,0,0]])Id = np.array([[1, 0], [0, 1]])#Define custom gates below### ###"""Defines all objects for making initial state and gate sets for simulation"""zero = np.array([0,0])rho_0 = np.tensordot(zero, zero,0)Clifford_1Q = {'S': S, 'H': H}Univ_1Q = {'S': S, 'H': H, 'T': T, 'X': X, 'Y': Y, 'Z': Z}Two_Q = {'CNOT': "CNOT"}Univ_A = {1: S, 2: H, 3: T, 4: "CNOT"}#Define Custom Dictionaries of one qubit and gates the size of system belowcust = {}###def cc(gate):    """    Returns complex conjugate of gate    Parameters    ----------    gate: list        Unitary gate that can be applied on a state    """    return np.transpose(np.matrix.conjugate(gate))def initial_state(dim):    """    Returns an initial state in a density matrix of dimension 2**n x 2**n    in the all zero state    Parameters    ----------    dim: int        dimension of the matrix to be created    """    state = np.zeros((dim,dim))    state[0][0] = 1    return state"""RANDOM CIRCUIT"""class RandomCirc:    """    Parameters    ----------    dim: int        2 to the number of qubits; dim of hilbert space    num_steps : int, optional        total number of steps. The default is 1.    state: list        Initial state position    gd: dict, optional        Dictionary of gates used    Lcustom: dict, optional        dictionary of custom gates size of system    """    def __init__(        self,        dim,        state,        num_steps: int = 1,        gd = Univ_A,            ):        self.num_steps = num_steps        self.dim = dim        self.state = state        self.gd = gd            ################# gate functions ##################################    def OneQGate(self, gate, qubit):        if qubit == 0:            fgate = gate        else:            fgate = Id        for i in range(1, self.dim):            if qubit == i:                fgate = np.kron(gate, fgate)            else:                fgate = np.kron(Id, fgate)        return fgate    def CNOT(self):        if random.random() > 0.5:            cqubit = random.randint(0, self.dim - 2)            if cqubit == 0:                fgate = CNotF            else:                fgate = Id            for i in range(1, self.dim - 1):                if i == cqubit:                    fgate = np.kron(CNotF, fgate)                else:                    fgate = np.kron(Id, fgate)        else:            cqubit = random.randint(1, self.dim-1)            if cqubit == 1:                fgate = CNotB            else:                fgate = Id            for i in range(1, self.dim-1):                if i == cqubit - 1:                    fgate = np.kron(CNotB, fgate)                else:                    fgate = np.kron(Id, fgate)        return fgate    ################# run functions ##################################    def experiment(self):        for i in range(self.num_steps):            gate = random.randint(1, len(self.gd))            if self.gd[gate] == "CNOT":                Cgate = self.CNOT()            else:                qubit = random.randint(0, self.dim-1)                Cgate = self.OneQGate(self.gd[gate], qubit)                                            self.state = np.matmul(Cgate, np.matmul(self.state, cc(Cgate)))                                """CUSTOM CIRCUIT"""class CustomCirc:    """    Parameters    ----------    dim: int        2 to the number of qubits; dim of hilbert space    state: list        Initial state position.     gd1: dict, optional        Dictionary of single qubit gates used    gd2: dict, optional        Dictionary of two qubit gates used    gdc: dict, optional        Dictionary of custom gates, size of matrix    """        def __init__(            self,             dim,             state,             gd1 = Univ_1Q,             gd2 = Two_Q,            gdc = cust        ):             self.dim = dim            self.state = state            self.gd1 = gd1            self.gd2 = gd2            self.gdc = gdc                ################# gate functions ##################################    def OneQgate(self, gate, qubit):                g = self.gd1[gate]        if qubit == 0:            fgate = g        else:            fgate = Id        for i in range(1, self.dim):            if qubit == i:                fgate = np.kron(g, fgate)            else:                fgate = np.kron(Id, fgate)        return fgate        def cnot(self, control, target):                if target > control:            if target - 1 == 0:                 fgate = CNotF            else:                 fgate = Id            for i in range(1, self.dim - 1):                if i == target-1:                    fgate = np.kron(CNotF, fgate)                else:                    fgate = np.kron(Id, fgate)            for i in range(target - 1, control, -1):                if i-1 == 0:                    sgate = CNotF                else:                    sgate = Id                for j in range(1, self.dim-1):                    if j == i-1:                        sgate= np.kron(CNotF, sgate)                    else:                        sgate = np.kron(Id, sgate)                                fgate = np.matmul(sgate, fgate)                fgate = np.matmul(fgate, fgate)        elif target < control:             if control == 1:                fgate = CNotB            else:                fgate = Id            for i in range(1, self.dim-1):                if i + 1 == control:                    fgate = np.kron(CNotB, fgate)                else:                    fgate = np.kron(Id, fgate)            for i in range(target, control-1):                if i == 0:                     sgate = CNotB                else:                    sgate = Id                for j in range(1, self.dim-1):                    if j == i:                         sgate = np.kron(CNotB, sgate)                    else:                        sgate = np.kron(Id, sgate)                fgate = np.matmul(sgate, fgate)                fgate = np.matmul(fgate, fgate)        return fgate        ################# run functions ##################################    def oneq(self, gate, qubit):        fgate = self.OneQgate(gate, qubit)        self.state = np.matmul(fgate, np.matmul(self.state, cc(fgate)))            def cnotg(self, control, target):        fgate = self.cnot(control, target)        self.state = np.matmul(fgate, np.matmul(self.state, cc(fgate)))            def custgate(self, gate):        fgate = self.gdc[gate]        self.state = np.matmul(fgate, np.matmul(self.state, cc(fgate)))            #%%dim = 3exp = CustomCirc(dim, initial_state(2**dim))exp.oneq('H', 0)print(exp.state)del exp#%%